// Containers:

template <typename T>
class vector {
    private:
        T* data;
        size_t size;
        size_t capacity;
    public:
        void size()

        T* begin() {data};
        T* end() {data + size};
         
}
A container is a holder object that stores a collection of other objects (its elements). They are implemented as class templates,
which allows a great flexibility in the types supported as elements.

The container manages the storage space for its elements and provides member functions to access them, either directly or through
iterators (reference objects with similar properties to pointers).

Many containers have several member functions in common, and share functionalities. The decision of which type of container to
use for a specific need does not generally depend only on the functionality offered by the container, but also on the efficiency
of some of its members (complexity). This is especially true for sequence containers, which offer different trade-offs in complexity
between inserting/removing elements and accessing them.

// Iterators:

In C++, iterators are objects that allow traversal through a sequence of elements in a container (like arrays, vectors, lists, etc.)
in a sequential manner. They provide a uniform way to access elements regardless of the underlying data structure. Iterators abstract
the details of accessing elements, allowing algorithms to operate on containers independently of their specific implementations.
They typically support operations like advancing to the next element, accessing the current element, and comparing against another iterator.


An iterator is an object that can iterate over elements in a C++ Standard Library container and provide access to individual elements.
The C++ Standard Library containers all provide iterators so that algorithms can access their elements in a standard way without having
to be concerned with the type of container the elements are stored in.

You can use iterators explicitly using member and global functions such as begin() and end() and operators such as ++ and -- to move forward
or backward. You can also use iterators implicitly with a range-for loop

std::vector<int> vec;
std::vector<int>::iterator it = vec.end();